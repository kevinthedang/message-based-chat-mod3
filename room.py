import logging

from numpy import int16
from users import *
from constants import *
from datetime import date, datetime
from pymongo import MongoClient, ReturnDocument
from collections import deque
from constants import *
from statsd import StatsClient

''' Task List for this file:
TODO: When reading in a message, we may want to move the the sequence number to the chatmessage class
        rather than the message property class, if this breaks we can try to do a bubble sort algorithm.
TODO: we want to remove a message by the user. so when taking a list of messages from a room, 
        we want to filter out the message by the user, most likely from the blacklist
TODO: we want to also search for a message by user id and return it
'''

logging.basicConfig(filename='message_chat.log', level=logging.DEBUG, format = LOG_FORMAT)

class MessageProperties():
    """ Class for holding the properties of a message: type, sent_to, sent_from, rec_time, send_time
        NOTE: The sequence number is defaulted to -1
    """
    def __init__(self, room_name: str, to_user: str, from_user: str, mess_type: int, sent_time: datetime = datetime.now(), rec_time: datetime = datetime.now()) -> None:
        self.__mess_type = mess_type
        self.__room_name = room_name
        self.__to_user = to_user
        self.__from_user = from_user
        self.__sent_time = sent_time
        self.__rec_time = rec_time     

    def to_dict(self):
        logging.error(f'sent time is {self.__sent_time}')
        return {'room_name': self.__room_name, 
            'mess_type': self.__mess_type,
            'to_user': self.__to_user, 
            'from_user': self.__from_user,
            'sent_time': self.__sent_time.isoformat(), # formating? users
            'rec_time': self.__rec_time, # formating? users
        } 

    # the following properties are to get functions to get message properties
    @property
    def message_type(self):
        return self.__mess_type

    @property
    def room_name(self):
        return self.__room_name

    @property
    def to_user(self):
        return self.__to_user

    @property
    def from_user(self):
        return self.__from_user

    @property
    def sent_time(self):
        return self.__sent_time

    @property
    def rec_time(self):
        return self.__rec_time

    def __str__(self):
        return str(self.to_dict())

class ChatMessage():
    """ Class for holding individual messages in a chat thread/queue. Each message has a message, sequence number, timestamp and type
        NOTE: message id is autogenerated by mongodb
    """
    def __init__(self, message: str, mess_id = None, mess_props: MessageProperties = None, sequence_number: int = -1, removed: bool = False) -> None:
        self.__message = message
        self.__mess_props = mess_props
        self.__mess_id = mess_id
        self.__sequence_num = sequence_number
        self.__removed = removed
        self.__dirty = True

    @property
    def message(self):
        return self.__message

    @property
    def message_properties(self):
        return self.__mess_props
    
    @property
    def dirty(self):
        return self.__dirty

    @dirty.setter
    def dirty(self, new_value):
        if type(new_value) is bool:
            self.__dirty = new_value

    @property
    def message_id(self):
        return self.__mess_id

    @message_id.setter
    def message_id(self, new_id):
        self.__mess_id = new_id

    @property
    def removed(self):
        return self.__removed

    @removed.setter
    def removed(self, new_value):
        if type(new_value) is bool:
            self.__removed = new_value
            self.dirty = True
    
    @property
    def sequence_num(self):
        return self.__sequence_num

    @sequence_num.setter
    def sequence_num(self, new_seq_num):
        if type(new_seq_num) is int:
            self.__sequence_num = new_seq_num
            self.dirty = True

    def to_dict(self):
        mess_props_dict = self.__mess_props.to_dict()
        return {'message': self.__message,
            'sequence_num': self.sequence_num,
            'mess_props': mess_props_dict,
            'removed': self.removed
        }

    def __str__(self):
        return f'Chat Message: {self.__message} - message props: {self.__mess_props}'

class ChatRoom(deque):
    """ We reuse the constructor for creating new or grabbing an existing instance. If owner_alias is empty and user_alias is not, 
            this is assuming an existing instance. The opposite (owner_alias set and user_alias empty) means we're creating new
            members is always optional, and room_type is only relevant if we're creating new.
    """
    def __init__(self, room_name: str, member_list: list = {}, owner_alias: str = "", room_type: int = ROOM_TYPE_PRIVATE, create_new: bool = False) -> None:
        super(ChatRoom, self).__init__()
        self.__room_name = room_name
        self.__user_list = UserList()
        # Set up mongo - client, db, collection, sequence_collection
        self.__mongo_client = MongoClient(host = MONGO_DB_HOST, port = MONGO_DB_PORT, username = MONGO_DB_USER, password = MONGO_DB_PASS, authSource = MONGO_DB_AUTH_SOURCE, authMechanism = MONGO_DB_AUTH_MECHANISM)
        self.__mongo_db = self.__mongo_client.get_database(MONGO_DB)
        self.__mongo_collection = self.__mongo_db.get_collection(self.__room_name) 
        self.__mongo_seq_collection = self.__mongo_db.get_collection("sequence")
        if self.__mongo_collection is None:
            self.__mongo_collection = self.__mongo_db.create_collection(self.__room_name)
        # Restore from mongo if possible, if not (or we're creating new) then setup ChatRoom properties
        if owner_alias not in member_list:
            member_list[owner_alias] = -1
        if create_new is True or self.restore() is False:
            self.__room_type = room_type
            self.__owner_alias = owner_alias
            self.__room_id = None
            self.__create_time = datetime.now()
            self.__modify_time = datetime.now()
            self.__member_list = member_list
            self.__dirty = True
            self.__deleted = False
            for current_member in member_list:
                if self.__user_list.get(current_member) is not None:
                    self.__member_list[current_member] = -1
                else:
                    '''put a log here to log an error for the member existence'''

    def __str__(self):
        return f'Chat room with name {self.__room_name}.'

    # property to get the name of a room
    @property
    def room_name(self):
        return self.__room_name

    @room_name.setter
    def name(self, new_name):
        if len(new_name) > 1:
            self.__room_name = new_name
            self.__dirty = True

    # property to get the list of users for a room
    @property
    def room_user_list(self):
        return self.__user_list

    # property to get the members list for a room
    @property
    def member_list(self):
        return self.__member_list

    # property to get the owner_alias of the 
    @property
    def owner_alias(self):
        return self.__owner_alias

    # property to get the length of the deque
    @property
    def num_messages(self):
        return len(self)

    # property to get the type of the room
    @property
    def room_type(self):
        return self.__room_type

    # property to get if the room is dirty
    @property
    def dirty(self):
        return self.__dirty

    @dirty.setter
    def dirty(self, new_value):
        if type(new_value) is bool:
            self.__dirty = new_value
            self.__modify_time = datetime.now()

    @property
    def deleted(self):
        return self.__deleted

    @deleted.setter
    def deleted(self, new_value):
        if type(new_value) is bool:
            self.__deleted = new_value
            self.dirty = True

    def __get_next_sequence_num(self):
        """ This is the method that you need for managing the sequence. Note that there is a separate collection for just this one document
        """
        sequence_num = self.__mongo_seq_collection.find_one_and_update(
                                                        {'_id': 'userid'},
                                                        {'$inc': {self.__room_name: 1}},
                                                        projection={self.__room_name: True, '_id': False},
                                                        upsert=True,
                                                        return_document=ReturnDocument.AFTER)
        return sequence_num

    def __get_current_sequence_num(self):
        ''' This method will get the sequence number from a specific ChatRoom instance
            NOTE: if the ChatRoom instance does not exist, return a -1 default value
        '''
        if (sequence_num := self.__mongo_seq_collection.find_one({ self.__room_name: { '$exists': 'true'}})) is None:
            return SEQUENCE_NUMBER_NOT_FOUND
        return sequence_num[self.__room_name]

    def __get_insertion_position(self, sequence_num: int) -> int:
        ''' This method is a helper method to get the insertion point for the new message
            for the message list
        '''
        current_low_index = 0
        current_high_index = self.num_messages - 1
        while self[current_low_index] < sequence_num < self[current_high_index]:
            current_middle = (current_high_index - current_low_index) // 2
            if sequence_num < self[current_middle].message_properties.sequence_num:
                current_high_index = current_middle
            elif sequence_num > self[current_middle].message_properties.sequence_num:
                current_low_index = current_middle
            else:
                '''insert log error here since we should have unique sequence numbers.'''
        return current_high_index

    #Overriding the queue type put and get operations to add type hints for the ChatMessage type
    def put(self, message: ChatMessage = None) -> None:
        ''' This method will put the current message to the left side of the deque
            TODO: put the message on the left using appendLeft() method
        '''
        logging.info(f'Calling the put() method with current message being {message} appending to the left of the deque.')
        if message is not None:
            super().appendleft(message)
            logging.info(f'{message} was appended to the left of the queue.')

    # overriding parent and setting block to false so we don't wait for messages if there are none
    def get(self) -> ChatMessage:
        ''' This method will take a ChatMessage from the right side of the deque.
            NOTE: the method pop() to take a value from the right of the deque
        '''
        try:
            message_right = super()[-1]
        except:
            logging.debug(f'There is no message in the deque for room {self.__room_name}')
            return None
        else:
            logging.debug(f'Message {message_right} was found on the deque.')
            return message_right

    def find_message(self, user_alias: str, message_text: str) -> ChatMessage:
        ''' Traverse through the deque of the Chatroom and find the ChatMessage 
                with the message_text input from the user.
        '''
        for current_message in list(self):
            if current_message.message == message_text:
                logging.debug(f'found "{message_text}" in deque.')
                if current_message.message_properties.from_user in self.__user_list.get(user_alias):
                    logging.warning(f'The message was from a user from the user_aliases blacklist, aborting.')
                return current_message
        logging.debug(f'{message_text} was not found in the deque.')
        return None
            
    def get_messages(self, user_alias: str, num_messages: int = GET_ALL_MESSAGES, return_objects: bool = True):
        ''' This method will get num_messages from the deque and get their text, objects and a total count of the messages
            NOTE: total # of messages seems to just be num messages, but if getting all then just return the length of the list
            NOTE: indecies 0 and 1 is to access the values in the tuple for the objects and the number of objects
        '''
        # return message texts, full message objects, and total # of messages
        if user_alias not in self.__member_list and self.__room_type is ROOM_TYPE_PRIVATE:
            logging.warning(f'User with alias {user_alias} is not a member of {self.__room_name}.')
            return [], [], 0
        current_user = self.__user_list.get(user_alias)
        '''IMPLEMENT GETTING MESSAGES WITH REGARD TO A BLACKLIST (AND IN MESSAGE OBJECTS) *******************
        OR this is handled in the API (mst)
        '''

        if return_objects is True:
            logging.debug('Returning messages with the message objects.')
            message_objects = self.__get_message_objects(num_messages = num_messages)
            if num_messages == GET_ALL_MESSAGES:
                return [current_message.message for current_message in list(self)], [{'message_object': message_obj.to_dict()} for message_obj in message_objects[0]], message_objects[1]
            else:
                message_texts = list()
                for current_message_index in range(RIGHT_SIDE_OF_DEQUE, RIGHT_SIDE_OF_DEQUE - num_messages, RANGE_STEP):
                    message_texts.append(super()[current_message_index].message)
                return message_texts, message_objects[0], message_objects[1]
        else:
            logging.debug('Returning messages without the message objects.')
            if num_messages == GET_ALL_MESSAGES:
                return [current_message.message for current_message in list(self)], len(self)
            else:
                message_texts = list()
                for current_message_index in range(RIGHT_SIDE_OF_DEQUE, RIGHT_SIDE_OF_DEQUE - num_messages, RANGE_STEP):
                    message_texts.append(super()[current_message_index].message)
                return message_texts, len(message_texts)

    def __get_message_objects(self, num_messages: int = GET_ALL_MESSAGES):
        ''' This is a helper method to get the actual message objects rather than just the message from the object
        '''
        logging.info(f'Attempting to get message objects in {self.__room_name}.')
        if num_messages == GET_ALL_MESSAGES:
            logging.debug('Returning all message objects in the deque.')
            return list(self), len(self)
        message_objects = list()
        for current_message_object in range(RIGHT_SIDE_OF_DEQUE, RIGHT_SIDE_OF_DEQUE - num_messages, RANGE_STEP):
            message_objects.append(super()[current_message_object].to_dict())
        logging.debug(f'Returning {num_messages} message objects from the deque.')
        return message_objects, len(message_objects)

    def __check_messages(self, message_object_list: list, user_alias: str) -> list:
        ''' This method will be a helper method that will get rid of any messages that are 
            removed or were blacklisted from the user
            TODO: implement removed cleaning
            TODO: implement blacklist cleaning
        '''
        cleaned_message_list = list()
        return cleaned_message_list

    def send_message(self, message: str, from_alias: str, mess_props: MessageProperties = None) -> bool:
        ''' This method will send a message to the ChatRoom instance
            NOTE: we are assuming that message is not None or empty
            NOTE: we most likely will need to utilize the put function to put the message on the queue
            NOTE: we also need to create an instance of ChatMessage to put on the queue
            NOTE: should we persist after putting the message on the deque.
        '''
        logging.info(f'Attempting to send {message} with the alias {from_alias}.')
        if from_alias in self.__member_list or self.__room_type is ROOM_TYPE_PUBLIC:
            logging.debug(f'{from_alias} was granted access to {self.__room_name} to send a message.')
            if mess_props is not None:
                new_message = ChatMessage(message = message, mess_props = mess_props)
                self.put(new_message)
                logging.debug(f'New ChatMessage created with message {message} and placed in the deque.')
                self.persist()
                return True
            else:
                logging.warning(f'No message properties given, cannot generate to_user for message properties. Failed to send message.')
                return False
        else:
            logging.debug(f'Alias {from_alias} is not a member of the private chat room {self.__room_name}.')
            return False

    def find_member(self, member_alias) -> str:
        ''' This method will find the member within the current ChatRoom instance
            NOTE: if the member is not found, return none
            TODO: log the possibility of not finding the member in the list
        '''
        for current_member in self.__member_list:
            if current_member == member_alias:
                return current_member
        # member was not found in the list of members (log this)
        return None

    def add_member(self, member_alias: str) -> int:
        ''' This method will attempt to add a member alias to the list of
            members for a ChatRoom instance.
            TODO: log for each case below
        '''
        if self.__user_list.get(member_alias) is None:
            return INVALID_USER
        if self.find_member(member_alias) is not None:
            return MEMBER_FOUND
        self.__member_list.append(member_alias)
        return MEMBER_ADDED

    def remove_member(self, member_alias):
        ''' This method will remove the member alias from the list of members for
            a ChatRoom instance
            TODO: log the situation below
        '''
        if member_alias in self.__member_list:
            self.__member_list.remove(member_alias)
        else:
            logging.warning(f'"{member_alias}" was not found in the member list')

    def find_message_by_sequence_num(self, sequence_num: int) -> ChatMessage:
        ''' This method will use binary search to find the message by the sequence number.
            NOTE: when the sequence number matches, we return the message that is found.
            NOTE: if there is no message found, we will return nothing.
        '''
        current_low_index = 0
        current_high_index = self.num_messages - 1
        while self[current_low_index] < sequence_num < self[current_high_index]:
            current_middle = (current_high_index - current_low_index) // 2
            if sequence_num < self[current_middle].message_properties.sequence_num:
                current_high_index = current_middle
            elif sequence_num > self[current_middle].message_properties.sequence_num:
                current_low_index = current_middle
            else:
                # add a log here for finding the message
                return self[current_middle]
        return None

    def find_message_by_alias(self, alias: str) -> list:
        ''' This method will return a list of messages from the deque if the message was sent
            by the alias provided.
            NOTE: the list can be empty
            NOTE: possibly check if the alias provided is a valid user?
        '''
        message_list = list()
        for current_chat_message in list(self):
            current_chat_message: ChatMessage
            if current_chat_message.message_properties.from_user == alias:
                message_list.append(current_chat_message)
        return message_list

    def find_message_by_keyword(self, keyword: str) -> list:
        ''' This method will return a list of messages from the deque if the message contains
            the keyword provided by the user.
            NOTE: how can we handle this if the keyword is None/empty?
        '''
        message_list = list()
        for current_chat_message in list(self):
            current_chat_message: ChatMessage
            if keyword in current_chat_message.message:
                message_list.append(current_chat_message)
        return message_list

    def restore(self) -> bool:
        ''' This method will restore the metadata and the messages that a certain ChatRoom instance needs
            NOTE: a ChatRoom will contain it's own collection, if we are creating a new collection, we don't
                    need to restore
        '''
        logging.info('Beginning the restore process.')
        room_metadata = self.__mongo_collection.find_one(filter = { 'room_name' : self.room_name })
        if room_metadata is None:
            logging.debug(f'Room name {self.__room_name} was not found in the collections.')
            return False
        self.__room_name = room_metadata['room_name']
        self.__owner_alias = room_metadata['owner_alias']
        self.__room_type = room_metadata['room_type']
        self.__member_list = room_metadata['member_list']
        self.__create_time = room_metadata['create_time']
        self.__modify_time = room_metadata['modify_time']
        self.__room_id = room_metadata['_id']
        self.__deleted = room_metadata['deleted']
        self.__dirty = False
        '''Implement sorting algorithm here!!!!!!!!!!!!!!!!!!!!!!!!!----------------------------------'''

        for current_message in self.__mongo_collection.find({'message': {'$exists': 'true'}}):
            message_properties = MessageProperties(room_name = current_message['mess_props']['room_name'],
                                                    to_user = current_message['mess_props']['to_user'],
                                                    from_user = current_message['mess_props']['from_user'],
                                                    mess_type = current_message['mess_props']['mess_type'],
                                                    sent_time = current_message['mess_props']['sent_time'],
                                                    rec_time = current_message['mess_props']['rec_time'])
            new_message = ChatMessage(message = current_message['message'], 
                                    mess_id = current_message['_id'], 
                                    mess_props = message_properties, 
                                    sequence_number = current_message['sequence_num'],
                                    removed = current_message['removed'])
            new_message.dirty = False
            self.put(message = new_message)
            logging.debug('Message ' + current_message['message'] + ' was placed onto the deque.')
        logging.info('All messages restored to the deque.')
        return True

    def persist(self):
        ''' This method will maintain the data inside of a ChatRoom instance:  
                - The metadata
                - The messages in the room.
            NOTE: we want to iterate through the deque
        '''
        logging.info(f'Beginning the persistence process for a chat room: {self.__room_name}.')
        if self.__mongo_collection.find_one({ 'room_name': self.__room_name }) is None:
            self.__room_id = self.__mongo_collection.insert_one({'room_name':self.__room_name,
                                                                'owner_alias': self.__owner_alias,
                                                                'room_type': self.__room_type,
                                                                'deleted': self.deleted,
                                                                'member_list': self.__member_list,
                                                                'create_time': self.__create_time,
                                                                'modify_time': self.__modify_time})
            logging.debug(f'Chatroom {self.__room_name} metadata has been added to the collection.')
        else:
            if self.__dirty == True:
                self.__mongo_collection.replace_one({'room_name':self.__room_name,
                                                    'owner_alias': self.__owner_alias,
                                                    'room_type': self.__room_type,
                                                    'deleted': self.deleted,
                                                    'member_list': self.__member_list,
                                                    'create_time': self.__create_time,
                                                    'modify_time': self.__modify_time},
                                                    upsert = True)
                logging.debug(f'Chatroom {self.__room_name} metadata has been updated in the collection.')
        self.__dirty = False
        # put messages in the collection now
        for current_message in list(self):
            if current_message.dirty == True:
                if current_message.message_id is None or self.__mongo_collection.find_one({ '_id' : current_message.message_id }) is None:
                    current_message.sequence_num = self.__get_next_sequence_num()
                    serialized = current_message.to_dict()
                    self.__mongo_collection.insert_one(serialized)
                    current_message.dirty = False


class RoomList():
    """ This is the RoomList class instance that will handle a list of ChatRooms and obtaining them.
        NOTE: no need to have properties as this will be the main handler of all other class instances.
    """
    def __init__(self, room_list_name: str = DEFAULT_ROOM_LIST_NAME) -> None:
        """ Try to restore from mongo and establish variables for the room list
            NOTE: restore will handle putting the rooms into the room_list
        """
        logging.info(f'Creating RoomList Instance: {room_list_name}')
        self.__room_list_name = room_list_name
        self.__room_list = list()
        self.__user_list = UserList()
        # Set up mongo - client, db, collection
        self.__mongo_client = MongoClient(host = MONGO_DB_HOST, port = MONGO_DB_PORT, username = MONGO_DB_USER, password = MONGO_DB_PASS, authSource = MONGO_DB_AUTH_SOURCE, authMechanism = MONGO_DB_AUTH_MECHANISM)
        self.__mongo_db = self.__mongo_client.get_database(MONGO_DB)
        self.__mongo_collection = self.__mongo_db.get_collection(room_list_name)
        if self.__mongo_collection is None:
            self.__mongo_collection = self.__mongo_db.create_collection(room_list_name)
        # Restore from mongo if possible, if not (or we're creating new) then setup properties
        if self.__restore() is not True:
            self.__room_list_create = datetime.now()
            self.__room_list_modify = datetime.now()
            self.__dirty = True

    def create(self, room_name: str, owner_alias: str, room_type: int = ROOM_TYPE_PRIVATE) -> ChatRoom:
        ''' This method will create a new ChatRoom given that the room_name is not already taken for the collection.
            NOTE: This can just be a checker for the chatroom name existing in the list when restored or if it's in the collection
            NOTE: Maybe check with the collection as it is possible for all names to not be in the list and removed, due to the option for removal
        '''
        logging.info(f'Attempting to create a ChatRoom instance with name {room_name}.')
        if self.get(room_name = room_name) is None:
            return ChatRoom(room_name = room_name, owner_alias = owner_alias, room_type = room_type, create_new = True)
        logging.debug(f'Instance of {room_name} collection already exists.')
        return None

    def add(self, new_room: ChatRoom) -> bool:
        ''' This method will add a ChatRoom instance to the list of ChatRooms
            NOTE: this method will add the list if the room name does not already exist in the list
        '''
        if new_room is None:
            logging.debug(f'This room already exists in {self.__room_list_name}.')
            return False
        self.__room_list.append(new_room)
        logging.debug(f'Chat room {new_room.room_name} added to the room list.')
        self.__dirty = True
        self.__persist()
        return True

    def remove(self, room_name: str):
        ''' This method will remove a ChatRoom instance from the list of ChatRooms.
            NOTE: we want to make sure that the ChatRoom instance with the given room_name exists.
            NOTE: accessing the property may not work
        '''
        chat_room_to_remove = self.__find_pos(room_name)
        if chat_room_to_remove is not CHAT_ROOM_INDEX_NOT_FOUND:
            self.__room_list[chat_room_to_remove].deleted = True
            logging.debug(f'ChatRoom {room_name} was removed from the room list.')
            self.__persist()
        else:
            logging.debug(f'ChatRoom {room_name} was not found in the room list.')

    def find_room_in_metadata(self, room_name: str) -> dict:
        ''' This method will return a dictionary of information, relating to the metadata...?
            NOTE: most likely this method will just access the metadata and find the room
            NOTE: metadata will consist of:
                    - room_name
                    - room_type
                    - owner_alias
                    - member_list
            NOTE: this is mainly for restoring a room_list
        '''
        if self.get(room_name = room_name) is None:
            logging.warning(f'No metadata can be found for {room_name}')
            return None
        else:
            room_found = self.get(room_name = room_name)
            return {
                'room_name': room_found.room_name,
                'room_type': room_found.room_type,
                'owner_alias': room_found.owner_alias,
                'member_list': room_found.member_list
            }

    def get_rooms(self):
        ''' This method will return the rooms in the room list, it now will check every room 
            if it has been removed from the room list
            NOTE: The room list can be empty
            
        '''
        logging.info('Returned the list of rooms.')
        visible_room_list = {}
        for room in self.__room_list:
            if room.deleted is not REMOVED_ROOM:
                visible_room_list[f'{room.room_name}'] = f'{room.room_type}'
        return visible_room_list

    def get(self, room_name: str) -> ChatRoom:
        ''' This method will return a ChatRoom instance, given the name of the room, room_name.
            The method now checks if the room instance has been removed or not
            NOTE: It is possible for a ChatRoom instance to not be in the list of rooms.
            NOTE: do we create a new ChatRoom if the chatroom was not found?
        '''
        logging.info(f'Attemping to get a chat room with name {room_name}.')
        for chat_room in self.__room_list:
            if chat_room.room_name == room_name and chat_room.deleted is not REMOVED_ROOM:
                logging.debug(f'{room_name} was found in the chat room list.')
                return chat_room
        logging.debug(f'{room_name} was not found in the chat room list.')
        return None

    def __find_pos(self, room_name: str) -> int:
        ''' This method is most likely a helper method for getting the position of a ChatRoom instance is in a list.
            NOTE: This maybe just for find_by_member and find_by_owner.
            NOTE: This is used for removing a chatroom instance in the list
        '''
        for chat_room_index in range(len(self.__room_list)):
            if self.__room_list[chat_room_index].room_name is room_name:
                logging.debug(f'{room_name} was found in the room list.')
                return chat_room_index
        logging.debug(f'Room name {room_name} was not found in the room list.')
        return CHAT_ROOM_INDEX_NOT_FOUND
    
    def find_by_member(self, member_alias: str) -> list:
        ''' This method will return a list of ChatRoom instances that has the the current alias within the list of
                member_aliases in the ChatRoom instance. The method now checks if the room instance has been removed from the list.
            NOTE: it is possible for all rooms to not have a the member_alias within their instance. return a empty list
            NOTE: create a new list and append the ChatRooms to the list.
            TODO: using the member_alias, find all rooms with a members_list that has this alias
            TODO: check if this member_alias is valid
        '''
        logging.info(f'Attempting to find chat rooms for member {member_alias} in {self.__room_list_name}.')
        if member_alias not in self.__user_list.user_aliases:
            logging.debug(f'Alias {member_alias} was not found in the list of users!')
            return []
        found_member_chat_rooms = list()
        for current_chat_room in self.__room_list:
            if member_alias in current_chat_room.member_list and current_chat_room.deleted is not REMOVED_ROOM:
                found_member_chat_rooms.append(current_chat_room)
        logging.info(f'Returning a list of chat rooms with the member alias of {member_alias}.')
        return found_member_chat_rooms

    def find_by_owner(self, owner_alias: str) -> list:
        ''' This method will return a list of ChatRoom instances that have an owner_alias that the user is searching for.
            NOTE: it is possible for all rooms to not have the current owner_alias, resulting in the list being empty.
        '''
        logging.info(f'Attempting to find chat rooms for owner {owner_alias} in {self.__room_list_name}.')
        if owner_alias not in self.__user_alias_list.user_aliases:
            logging.debug(f'Owner alias {owner_alias} was not found in the list of users!')
            return []
        found_owner_chat_rooms = list()
        for current_chat_room in self.__room_list:
            if owner_alias is current_chat_room.owner_alias and current_chat_room.deleted is not REMOVED_ROOM:
                found_owner_chat_rooms.append(current_chat_room)
        logging.info(f'Returning a list of chat rooms with the owner alias of {owner_alias}.')
        return found_owner_chat_rooms

    def __persist(self):
        ''' This method will save the metadata of the RoomList class and push it to the collections
            NOTE: the metadata should contain the list of room_names in the metadata where we would collect the room_names and find the room based on
        '''
        logging.info(f'Beginning the persistence process for the room list: {self.__room_list_name}')
        if self.__mongo_collection.find_one({ 'list_name': self.__room_list_name }) is None:
            logging.info(f'Persisting new room list {self.__room_list_name}.')
            self.__room_id = self.__mongo_collection.insert_one({'list_name':self.__room_list_name,                                                            
                                                                'create_time': self.__room_list_create,
                                                                'modify_time': self.__room_list_modify,
                                                                'rooms_metadata': [self.find_room_in_metadata(room.room_name) for room in self.__room_list]}) # metadata here
        else:
            if self.__dirty == True:
                logging.debug(f'Updating persistence of {self.__room_list_name} metadata.')
                self.__mongo_collection.replace_one(filter = { 'list_name': self.__room_list_name },
                                                    replacement = {'list_name':self.__room_list_name,                                                   
                                                    'create_time': self.__room_list_create,
                                                    'modify_time': self.__room_list_modify,
                                                    'rooms_metadata': [self.find_room_in_metadata(room.room_name) for room in self.__room_list]},
                                                    upsert = True) # metadata here and upsert = True to update the room metadata
        self.__dirty = False

    def __restore(self) -> bool:
        ''' This method will load the metadata from the collection of the RoomList class and load it to the instance.
            NOTE: the collection will have to be checked for all ChatRoom aliases
            TODO: take in the rooms_metadata for one of the methods
            TODO: restore all of the chat rooms through the metadata in the collections.
        '''
        logging.info('Beginning the restore process.')
        room_metadata = self.__mongo_collection.find_one({ 'list_name' : self.__room_list_name })
        if room_metadata is None:
            logging.warning(f'Room name {self.__room_list_name} was not found in the collections.')
            return False
        self.__room_list_name = room_metadata['list_name']
        self.__room_list_create = room_metadata['create_time']
        self.__room_list_modify = room_metadata['modify_time']
        self.__rooms_metadata = room_metadata['rooms_metadata']
        logging.info(f'Attempting to load chat rooms into room list.')
        for current_room_metadata in self.__rooms_metadata:
            new_chatroom = ChatRoom(room_name = current_room_metadata['room_name'],
                                    member_list = current_room_metadata['member_list'],
                                    owner_alias = current_room_metadata['owner_alias'],
                                    room_type = current_room_metadata['room_type'])
            self.__room_list.append(new_chatroom)
            logging.debug('Room ' + current_room_metadata['room_name'] + ' has been added to the room list.')
        logging.info(f'All rooms in {self.__room_list_name} placed into the room list.')
        self.__dirty = False
        return True